/* ... весь HTML-код... */

    <!-- Блок JavaScript -->
    <script type="module">
        import { initializeApp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-app.js";
        import { getAuth, signInAnonymously, signInWithCustomToken, onAuthStateChanged } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-auth.js";
        import { getFirestore, doc, setDoc, onSnapshot, runTransaction, serverTimestamp } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        import { setLogLevel } from "https://www.gstatic.com/firebasejs/11.6.1/firebase-firestore.js";
        
        // Включаем логирование для дебага
        setLogLevel('debug');

        // --- ГЛОБАЛЬНЫЕ КОНСТАНТЫ И ПЕРЕМЕННЫЕ (ВСТАВЬТЕ СВОИ КЛЮЧИ СЮДА) ---
        
        const XP_GAINS = {
            feed: 20,
            train: 30,
            clean: 10,
            play: 25
        };

        const LEVELS = [
            { name: 'Пупка (Початкова Молекула)', minXp: 0, maxXp: 100, description: 'Маленька, але жвава істота' },
            { name: 'Мікроорганізм', minXp: 101, maxXp: 250, description: 'Починає рухатись і світитись' },
            { name: 'Клітинка Життя', minXp: 251, maxXp: 500, description: 'Має силу й форму' },
            { name: 'Маленьке Звірятко', minXp: 501, maxXp: 900, description: 'Починає проявляти характер' },
            { name: 'Людинка-Пупка', minXp: 901, maxXp: 1500, description: 'Має почуття та здібності' },
            { name: 'Справжній Пупкозавр', minXp: 1501, maxXp: 999999, description: 'Легенда, непереможний і нескінченний' }
        ];

        const INITIAL_PUPKA_DATA = {
            xp: 0,
            health: 100,
            pupkaImage: 'https://placehold.co/400x400/818CF8/FFFFFF?text=Pupka',
            lastActionTimestamp: null,
            lastActionXP: 0,
            lastActionType: null,
            lastUndoTimestamp: null,
            createdAt: serverTimestamp(),
        };

        const HEALTH_DECREASE_RATE = 1; // Health decrease per hour
        const MAX_HEALTH = 100;
        const UNDO_COOLDOWN_HOURS = 1;

        // --- FIREBASE ИНИЦИАЛИЗАЦИЯ (ВСТАВЬТЕ СВОИ РЕАЛЬНЫЕ КЛЮЧИ СЮДА) ---
        
        // ВАЖЛИВО: Замініть ці заглушки на ваші реальні дані Firebase
        const appId = typeof __app_id !== 'undefined' ? __app_id : 'default-app-id';
        const firebaseConfig = JSON.parse(typeof __firebase_config !== 'undefined' ? __firebase_config : '{}');
        const initialAuthToken = typeof __initial_auth_token !== 'undefined' ? __initial_auth_token : null;

        const app = initializeApp(firebaseConfig);
        const db = getFirestore(app);
        const auth = getAuth(app);
        
        let userId = null;
        let pupkaRef = null;
        let gameState = { ...INITIAL_PUPKA_DATA };
        
        // DOM-элементы (остались прежними)
        const loadingOverlay = document.getElementById('loading-overlay');
        const appContainer = document.getElementById('app-container');
        const userIdDisplay = document.getElementById('user-id-display');
        const pupkaImg = document.getElementById('pupka-img');
        const xpValue = document.getElementById('xp-value');
        const xpProgress = document.getElementById('xp-progress');
        const levelInfo = document.getElementById('level-info');
        const healthValue = document.getElementById('health-value');
        const healthProgress = document.getElementById('health-progress');
        const lastActionDisplay = document.getElementById('last-action-display');
        const statusDisplay = document.getElementById('status-display');
        const undoBtn = document.getElementById('undo-btn');
        const modalContainer = document.getElementById('modal-container');
        const modalTitle = document.getElementById('modal-title');
        const modalMessage = document.getElementById('modal-message');
        const modalConfirmBtn = document.getElementById('modal-confirm-btn');
        const modalCancelBtn = document.getElementById('modal-cancel-btn');

        // --- УТИЛИТЫ ---
        
        /**
         * Вычисляет уровень Пупки на основе XP. (Остается прежней)
         * @param {number} xp 
         * @returns {{level: number, info: object, progress: number}}
         */
        const calculateLevelInfo = (xp) => {
            let levelIndex = LEVELS.findIndex(l => xp >= l.minXp && xp <= l.maxXp);
            if (levelIndex === -1) {
                levelIndex = LEVELS.length - 1;
            }
            const currentLevel = LEVELS[levelIndex];
            const nextLevel = LEVELS[levelIndex + 1] || currentLevel;
            
            const xpForLevel = currentLevel.maxXp - currentLevel.minXp;
            const xpGainedInLevel = xp - currentLevel.minXp;
            
            let progress = 100;
            let xpUntilNext = 0;

            if (nextLevel !== currentLevel) {
                progress = Math.min(100, (xpGainedInLevel / xpForLevel) * 100);
                xpUntilNext = nextLevel.minXp - xp;
            }

            return {
                level: levelIndex + 1,
                info: currentLevel,
                progress: progress,
                xpUntilNext: xpUntilNext > 0 ? xpUntilNext : 0
            };
        };

        /**
         * Вычисляет текущий статус Пупки (здоровье и время). (Остается прежней)
         * @param {object} data
         * @returns {{text: string, type: 'error'|'warning'|'success'|'info', icon: string}}
         */
        const calculateStatus = (data) => {
            const health = data.health;
            const lastActionTime = data.lastActionTimestamp ? data.lastActionTimestamp.toDate() : new Date(0);
            const now = new Date();
            const timeSinceLastAction = (now - lastActionTime) / (1000 * 60 * 60); // Hours

            if (health <= 0) {
                return { text: 'Пупка померла від голоду та самотності...', type: 'error', icon: 'x-circle' };
            }
            if (health < 20) {
                return { text: 'Критичний стан! Терміново допоможіть Пупці!', type: 'error', icon: 'heart' };
            }
            if (health < 50) {
                return { text: 'Пупка голодна і сумна. Потребує уваги!', type: 'warning', icon: 'clock' };
            }
            if (timeSinceLastAction > 12) {
                return { text: 'Давно не заходили. Здоров\'я сильно знизилось.', type: 'warning', icon: 'clock' };
            }
            if (timeSinceLastAction < 1) {
                return { text: 'Пупка щаслива! Нещодавно про неї піклувалися.', type: 'success', icon: 'check-circle' };
            }
            return { text: 'Пупка в нормі. Чекає на нові пригоди!', type: 'info', icon: 'smile' };
        };

        /**
         * Рассчитывает уменьшение здоровья с момента последнего действия.
         * ИСПРАВЛЕНО: Добавлены проверки на наличие timestamp.
         * @param {object} data 
         * @returns {number} Новое значение здоровья
         */
        const calculateCurrentHealth = (data) => {
            if (data.health <= 0) return 0;

            let lastTimestamp;
            // Ищем наиболее актуальную метку времени: lastAction, createdAt, или текущее время (если ничего нет)
            if (data.lastActionTimestamp && typeof data.lastActionTimestamp.toDate === 'function') {
                lastTimestamp = data.lastActionTimestamp.toDate();
            } else if (data.createdAt && typeof data.createdAt.toDate === 'function') {
                lastTimestamp = data.createdAt.toDate();
            } else {
                lastTimestamp = new Date(); // Fallback
            }

            const now = new Date();
            const hoursPassed = (now - lastTimestamp) / (1000 * 60 * 60);
            
            const healthLoss = Math.floor(hoursPassed * HEALTH_DECREASE_RATE);
            // Возвращаем целое число здоровья, чтобы избежать проблем с типами
            return Math.max(0, Math.floor(data.health - healthLoss));
        };

        // --- РАБОТА С UI (ЗАМЕНА РЕНДЕРА REACT) --- (Остается прежней)

        const showModal = (title, message, isConfirm = false) => {
            // ... (Код showModal остается прежним)
            modalTitle.textContent = title;
            modalMessage.textContent = message;
            
            if (isConfirm) {
                modalCancelBtn.classList.remove('hidden');
                modalConfirmBtn.classList.remove('hidden');
            } else {
                modalCancelBtn.classList.add('hidden');
                modalConfirmBtn.classList.add('hidden');
            }
            
            modalContainer.classList.remove('hidden');
            modalContainer.classList.add('flex');

            return new Promise(resolve => {
                const handleConfirm = () => {
                    modalContainer.classList.add('hidden');
                    modalContainer.classList.remove('flex');
                    modalConfirmBtn.removeEventListener('click', handleConfirm);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(true);
                };
                const handleCancel = () => {
                    modalContainer.classList.add('hidden');
                    modalContainer.classList.remove('flex');
                    modalConfirmBtn.removeEventListener('click', handleConfirm);
                    modalCancelBtn.removeEventListener('click', handleCancel);
                    resolve(false);
                };

                if (isConfirm) {
                    modalConfirmBtn.addEventListener('click', handleConfirm);
                    modalCancelBtn.addEventListener('click', handleCancel);
                } else {
                    modalContainer.addEventListener('click', (e) => {
                        if (e.target === modalContainer) handleConfirm();
                    }, { once: true });
                }
            });
        };

        const updateStatusDisplay = (status) => {
            // ... (Код updateStatusDisplay остается прежним)
            const icons = lucide.createIcons();
            let colorClass = '';
            
            switch (status.type) {
                case 'error': colorClass = 'bg-red-100 text-red-700 border-red-500'; break;
                case 'warning': colorClass = 'bg-yellow-100 text-yellow-700 border-yellow-500'; break;
                case 'success': colorClass = 'bg-green-100 text-green-700 border-green-500'; break;
                case 'info': colorClass = 'bg-indigo-100 text-indigo-700 border-indigo-500'; break;
                default: colorClass = 'bg-gray-100 text-gray-700 border-gray-500';
            }

            statusDisplay.innerHTML = `
                <div class="p-4 rounded-xl shadow-lg border-l-4 font-semibold max-w-xs ${colorClass} flex items-center w-full">
                    <span class="w-5 h-5 mr-3 ${status.type === 'info' ? 'animate-spin' : ''}">
                       ${icons[status.icon] ? icons[status.icon].toSvg() : icons['help-circle'].toSvg()}
                    </span>
                    ${status.text}
                </div>
            `;
        };
        
        const updateUI = () => {
            // ... (Код updateUI остается прежним)
            if (!gameState || !userId) return;

            // 1. Обновление User ID
            userIdDisplay.textContent = userId;
            
            // 2. Вычисление и обновление здоровья
            const currentHealth = calculateCurrentHealth(gameState);
            const healthProgressPct = currentHealth;
            
            healthValue.textContent = `${currentHealth}%`;
            healthProgress.style.width = `${healthProgressPct}%`;
            healthProgress.classList.remove('bg-red-500', 'bg-orange-500', 'bg-green-500');
            if (currentHealth < 20) {
                healthProgress.classList.add('bg-red-500');
            } else if (currentHealth < 50) {
                healthProgress.classList.add('bg-orange-500');
            } else {
                healthProgress.classList.add('bg-green-500');
            }

            // 3. Вычисление и обновление XP/Уровня
            const { level, info, progress, xpUntilNext } = calculateLevelInfo(gameState.xp);
            
            xpValue.textContent = gameState.xp;
            xpProgress.style.width = `${progress}%`;
            
            let levelText = `Рівень ${level}: ${info.name}. ${info.description}`;
            if (xpUntilNext > 0) {
                levelText += ` (${xpUntilNext} XP до наступного рівня)`;
            }
            levelInfo.textContent = levelText;

            // 4. Обновление статуса
            updateStatusDisplay(calculateStatus({ ...gameState, health: currentHealth }));

            // 5. Обновление изображения
            pupkaImg.src = gameState.pupkaImage || 'https://placehold.co/400x400/818CF8/FFFFFF?text=Pupka';

            // 6. Обновление Последнего действия
            const lastActionTime = gameState.lastActionTimestamp && typeof gameState.lastActionTimestamp.toDate === 'function' 
                ? gameState.lastActionTimestamp.toDate().toLocaleString('uk-UA') 
                : 'Ніколи';
            lastActionDisplay.textContent = `Остання дія: ${gameState.lastActionType || 'Нічого'} (+${gameState.lastActionXP} XP) о ${lastActionTime}`;

            // 7. Обновление кнопки отмены (Cooldown)
            const now = new Date().getTime();
            const lastUndo = gameState.lastUndoTimestamp && typeof gameState.lastUndoTimestamp.toDate === 'function' ? gameState.lastUndoTimestamp.toDate().getTime() : 0;
            const cooldownMs = UNDO_COOLDOWN_HOURS * 60 * 60 * 1000;
            const canUndo = now - lastUndo > cooldownMs;

            if (canUndo && gameState.lastActionType && gameState.lastActionXP > 0) {
                undoBtn.disabled = false;
                undoBtn.classList.remove('bg-gray-400', 'cursor-not-allowed');
                undoBtn.classList.add('bg-gray-700', 'hover:bg-gray-800');
            } else {
                undoBtn.disabled = true;
                undoBtn.classList.add('bg-gray-400', 'cursor-not-allowed');
                undoBtn.classList.remove('bg-gray-700', 'hover:bg-gray-800');
                if (!canUndo) {
                    const nextTime = new Date(lastUndo + cooldownMs).toLocaleTimeString('uk-UA');
                    undoBtn.title = `Скасування буде доступне після ${nextTime}`;
                } else if (!gameState.lastActionType) {
                    undoBtn.title = `Немає дій для скасування`;
                }
            }
            
            // Запускаем отрисовку иконок после обновления DOM
            lucide.createIcons();
        };

        // --- FIREBASE LOGIC ---
        
        /**
         * Главная функция для выполнения игровых действий (запись в Firestore)
         * ИСПРАВЛЕНО: Улучшена обработка docSnapshot.data() и обновлен расчет времени.
         * @param {string} type - Тип действия ('feed', 'train', 'clean', 'play')
         */
        const performAction = async (type) => {
            if (!pupkaRef || calculateCurrentHealth(gameState) <= 0) {
                await showModal('Помилка', 'Пупка померла. Скиньте гру, щоб почати знову!', false);
                return;
            }

            try {
                const xpGain = XP_GAINS[type];

                await runTransaction(db, async (transaction) => {
                    const docSnapshot = await transaction.get(pupkaRef);
                    // Инициализируем данные, если документа нет, или используем существующие
                    const currentData = docSnapshot.exists() 
                        ? { ...INITIAL_PUPKA_DATA, ...docSnapshot.data() }
                        : INITIAL_PUPKA_DATA;

                    // 1. Рассчитываем текущее здоровье перед действием
                    const currentHealth = calculateCurrentHealth(currentData);

                    // 2. Применяем изменения
                    const newHealth = Math.min(MAX_HEALTH, currentHealth + 10); // +10 к здоровью за любое действие
                    const newXP = currentData.xp + xpGain;
                    
                    const newData = {
                        // Важно: всегда используем Spread Operator, чтобы не потерять скрытые поля
                        ...currentData,
                        xp: newXP,
                        health: newHealth,
                        lastActionTimestamp: serverTimestamp(), // Обновляем timestamp
                        lastActionXP: xpGain,
                        lastActionType: type,
                        // Убеждаемся, что createdAt имеет timestamp (если документ создан впервые)
                        createdAt: currentData.createdAt || serverTimestamp(), 
                        // lastUndoTimestamp не трогаем, если это не отмена
                    };

                    transaction.set(pupkaRef, newData);
                });
                
                await showModal('Дія виконана!', `Ви виконали дію "${type}". Пупка отримала +${xpGain} XP та +10 Здоров'я.`, false);

            } catch (e) {
                console.error("Transaction failed: ", e);
                // Если ошибка связана с Firebase, показываем ее пользователю
                const errorMessage = e.message ? `Помилка: ${e.message}` : 'Не вдалося виконати дію. Спробуйте ще раз.';
                await showModal('Помилка', errorMessage, false);
            }
        };

        /**
         * Функция отмены последнего действия. (Остается прежней, но с проверками)
         */
        const undoLastAction = async () => {
            if (!pupkaRef || !gameState.lastActionType || gameState.lastActionXP === 0) {
                 await showModal('Увага', 'Немає дії для скасування або дія вже скасована.', false);
                 return;
            }
            
            const now = new Date().getTime();
            const lastUndo = gameState.lastUndoTimestamp && typeof gameState.lastUndoTimestamp.toDate === 'function' ? gameState.lastUndoTimestamp.toDate().getTime() : 0;
            const cooldownMs = UNDO_COOLDOWN_HOURS * 60 * 60 * 1000;
            if (now - lastUndo < cooldownMs) {
                const nextTime = new Date(lastUndo + cooldownMs).toLocaleTimeString('uk-UA');
                await showModal('Увага', `Скасування можна робити лише раз на годину. Спробуйте після ${nextTime}.`, false);
                return;
            }

            const confirmed = await showModal(
                'Скасувати дію',
                `Ви впевнені, що хочете скасувати останню дію "${gameState.lastActionType}" (-${gameState.lastActionXP} XP)?`,
                true
            );

            if (!confirmed) return;

            try {
                const xpLoss = gameState.lastActionXP;

                await runTransaction(db, async (transaction) => {
                    const docSnapshot = await transaction.get(pupkaRef);
                    const currentData = docSnapshot.exists() ? docSnapshot.data() : INITIAL_PUPKA_DATA;

                    const newXP = Math.max(0, currentData.xp - xpLoss);
                    
                    const newData = {
                        ...currentData,
                        xp: newXP,
                        // Скидываем данные о последнем действии
                        lastActionXP: 0,
                        lastActionType: null,
                        // lastActionTimestamp остается прежним, так как мы отменили только XP/Health
                        lastUndoTimestamp: serverTimestamp(), // Устанавливаем метку отмены для кулдауна
                    };

                    transaction.set(pupkaRef, newData);
                });

                await showModal('Успіх', 'Остання дія успішно скасована.', false);

            } catch (e) {
                console.error("Undo transaction failed: ", e);
                await showModal('Помилка', 'Не вдалося скасувати дію.', false);
            }
        };

        /**
         * Сброс данных игры. (Остается прежней)
         */
        const resetGame = async () => {
             // ... (Код resetGame остается прежним)
            const confirmed = await showModal(
                'Скинути гру',
                'Ця дія безповоротно видалить ваш прогрес. Ви впевнені?',
                true
            );

            if (!confirmed) return;

            if (!pupkaRef) {
                await showModal('Помилка', 'Немає посилання на базу даних.', false);
                return;
            }

            try {
                await setDoc(pupkaRef, INITIAL_PUPKA_DATA);
                await showModal('Успіх', 'Гра успішно скинута. Пупка народилася знову!', false);
            } catch (e) {
                console.error("Reset failed: ", e);
                await showModal('Помилка', 'Не вдалося скинути гру. Спробуйте ще раз.', false);
            }
        };

        /**
         * Сохранение загруженного изображения. (Остается прежней)
         */
        const saveImage = async () => {
             // ... (Код saveImage остается прежней)
            const fileInput = document.getElementById('image-upload');
            const file = fileInput.files[0];
            
            if (!file) {
                await showModal('Увага', 'Спочатку виберіть файл зображення.', false);
                return;
            }
            
            if (!pupkaRef) return;

            const reader = new FileReader();
            reader.onload = async function(event) {
                const base64Image = event.target.result;

                if (base64Image.length > 1024 * 1024 * 1.33) { 
                    await showModal('Помилка', 'Зображення завелике! Максимальний розмір даних документа Firestore становить 1 МБ.', false);
                    return;
                }

                try {
                    await runTransaction(db, async (transaction) => {
                        const docSnapshot = await transaction.get(pupkaRef);
                        const currentData = docSnapshot.exists() ? docSnapshot.data() : INITIAL_PUPKA_DATA;
                        
                        transaction.update(pupkaRef, { pupkaImage: base64Image });
                    });
                    
                    await showModal('Успіх', 'Зображення Пупки успішно збережено!', false);
                } catch (e) {
                    console.error("Image save failed: ", e);
                    await showModal('Помилка', 'Не вдалося зберегти зображення.', false);
                }
            };
            reader.readAsDataURL(file);
        };

        // --- ГЛАВНАЯ ИНИЦИАЛИЗАЦИЯ И СЛУШАТЕЛИ FIREBASE ---
        
        const setupFirestoreListener = (currentUserId) => {
             // ... (Код setupFirestoreListener остается прежним)
            const collectionPath = `artifacts/${appId}/users/${currentUserId}/pupka_game`;
            pupkaRef = doc(db, collectionPath, 'main_pupka_data');
            
            onSnapshot(pupkaRef, (docSnap) => {
                if (docSnap.exists()) {
                    gameState = docSnap.data();
                    console.log("Firestore data received:", gameState);
                    updateUI();
                } else {
                    console.log("No Pupka data found, creating initial document.");
                    setDoc(pupkaRef, INITIAL_PUPKA_DATA);
                }
            }, (error) => {
                console.error("Error listening to Firestore:", error);
                // Проверяем, является ли ошибка ошибкой безопасности (Permission Denied)
                if (error.code === 'permission-denied') {
                    showModal('Помилка доступу до бази даних', 'Перевірте Правила Безпеки (Security Rules) у Firebase. Доступ до даних заборонено!', false);
                } else {
                    showModal('Помилка підключення', 'Не вдалося підключитися до бази даних Firestore.', false);
                }
            });
        };

        const initializeAppAndAuth = async () => {
             // ... (Код initializeAppAndAuth остается прежним)
            try {
                if (initialAuthToken) {
                    await signInWithCustomToken(auth, initialAuthToken);
                } else {
                    await signInAnonymously(auth);
                }

                onAuthStateChanged(auth, (user) => {
                    if (user) {
                        userId = user.uid;
                        setupFirestoreListener(userId);
                        
                        loadingOverlay.classList.add('hidden');
                        appContainer.classList.remove('hidden');
                        
                    } else {
                        console.error("User not authenticated.");
                        showModal('Помилка авторизації', 'Не вдалося увійти в систему. Перезавантажте сторінку.', false);
                    }
                });
            } catch (e) {
                console.error("Firebase Initialization Failed:", e);
                showModal('Критична помилка', 'Не вдалося ініціалізувати Firebase. Перевірте ключі.', false);
            }
        };

        // --- НАСТРОЙКА DOM-СЛУШАТЕЛЕЙ ---

        document.addEventListener('DOMContentLoaded', () => {
             // ... (Код DOM-слушателей остается прежним)
            initializeAppAndAuth();

            document.getElementById('feed-btn').addEventListener('click', () => performAction('feed'));
            document.getElementById('train-btn').addEventListener('click', () => performAction('train'));
            document.getElementById('clean-btn').addEventListener('click', () => performAction('clean'));
            document.getElementById('play-btn').addEventListener('click', () => performAction('play'));
            
            undoBtn.addEventListener('click', undoLastAction);
            
            document.getElementById('reset-btn').addEventListener('click', resetGame);
            document.getElementById('save-image-btn').addEventListener('click', saveImage);
            
            lucide.createIcons();
        });
        
    </script>
